# Js初见

> 1. 基于原型,解释性(不需要编译)脚本(寄生)语言.
> 2. 组成: ECMAscript(对js基本语法和对象的说明),DOM,BOM.

# js名词解释 

> js代码从上往下逐行解释执行,js语句后以;结尾,表达式(计算式)和语句(命令)区别:表达式必有一个返回值,语句不一定有,比如: 2 + 2 是表达式, console.log(2); 是语句。

## JS变量

> 声明并赋值: var 变量名 = 变量值;  初始不赋值,默认为undefined
>
> ```
> var page = 2 + 2;
> 分为两步,先声明了page变量,再计算2 + 2表达式的值赋值给page。
> ```

# JS变量命名规则和规范

> 1. 由数字,字母,下划线,$组成
> 2.  不能以数字开头
> 3. 不能是保留字

> 1. 具有语义性的单词
> 2. 多个单词用小驼峰命名
> 3. 变量名为形容词/名词 + 名词形式,不能有动词.

## 变量规则

> 1.未声明变量直接使用: 报错 not defined
>
> 2.省略var关键字进行赋值,js解释器发现赋值操作但变量未声明,会帮助我们对未声明变量进行声明.
>
> ```
> a = 200;
> console.log(a); //200
> ```
>
> 3.重复赋值,值会进行覆盖.
>
> 4.重复声明,只会采用该变量的第一次声明.之后的声明无效
>
> 5.重复声明赋值,声明只有第一次有效,但赋值操作均有效.
>
> 6.批量声明
>
> ```
> var allPage, allTime, allPerson = 20;
> 3个变量都进行了声明,但只有allPerson变量进行了赋值.
> ```
>
> 7.批量声明赋值
>
> ``` 
> var allPage = allPerson = allSchool = 20;
> 从右往左,依次进行赋值操作,js解释器进行隐式声明,最终3个变量值都为20
> ```
>
> 8.变量提升
>
> ```
> 将所有声明操作提到该作用域顶部,赋值操作位置不变.
> ```
>
> 

## 数据类型

> number,string,boolean,undefined,null,object,symbol
>
> 分类: number string boolean为基本数据类型,不可再分,根据存储位置也可以把除object外的类型都分为基础类型,因为他们存储在栈内存中.

## 数据类型值Number

> 1.浮点数计算存在精度问题
>
> 2.具体最大值和最小值 Number.MAX_VALUE,Number.MIN_VALUE,抽象最大值和最小值,Infinity,-Infinity.
>
> 3.NaN,一般出现在数字计算表达式出现问题,无法得到数字结果.成为返回值.
>
> 判断一个值是不是NaN的办法,只有通过isNaN(数值)进行,返回true或者false.
>
> ``` 
> var good = 2 - "JZS"; //NaN
> console.log(good === NaN); //false
> console.log(NaN === NaN) //false
> console.log(isNaN(good)) //true
> ```
>
> 4.isNaN(数值),使用isNaN(数值),会先把数值转化为number类型,
>
> 比如字符串会被转化为NaN,则结果为true
>
> 比如true会被转化为1,结果为false
>
> 比如null会被转化为0,结果为false.
>
> 所有一般应用场景需要避免这种情况出现,在使用isNaN()前,先对要使用的数据进行判断,是否为number类型.
>
> tip:对于空数组和单数据(数据字符串)数组,会被判断为是number,返回false.NaN进行数学运算仍为NaN。

## String类型

> 1. length和字符串[index]是只读,不可修改
>
> 2. 字符串书写换行和显示换行
>
>    ``` 
>    var page = "吃饭"
>    + "睡觉"
>    + "打游戏"
>    ;
>    var secondPage = "好 \
>    好的 \
>    好的的 \
>    ";
>    var otherLine = "吃饭\n睡觉\n打游戏";
>    var otherLine = "吃饭" + "\n" + "睡觉" + "\n" +"打游戏";
>    ```
>
> 3. 转义字符
>
>    ```
>    var food = "'使用单引号'\'我是单引号\'";  除了包裹的"",剩下的引号都是字符串.
>    var question = "\"\\\"";
>    ```
>
>    

## Boolean

> 字面值: false,true
>
> 在被转化为数值时,false被转化为0,true为1.

## Undefined 和 null

> null用于清空变量指向的内存空间
>
> undefined表示变量的初始值,内存空间仍然保留。

## 类型判断之typeof

> ```
> typeof null; //object
> typeof 未声明的标识符; //不会报错,而是返回undefined
> ```
>
> 

## isFinite() 判断是否为正常数值

> ``` 
> console.log(isFinite(Infinity)); //false
>     console.log(isFinite(-Infinity)); //false
>     console.log(isFinite(true)); //true
>     console.log(isFinite(22)); //true
>     console.log(isFinite("22")); //true
>     console.log(isFinite("jzs")); //false
>     console.log(isFinite(undefined)); //false
>     console.log(isFinite(null)); //true
>     console.log(isFinite(NaN)); //false
> ```
>
> 

## 操作符

### 运算操作符

> ```
> num++和++num区别: num = num + 1的顺序,在需要获取该表达式值的时候,前者先把自身num值返回,再进行自加,后者先进行自加,再把num自身返回。
> ```
>
> + tip: 数 / 0 结果为 Infinity, 数 / -0 结果为 -Infinity
>
> > 算数运算符: + = * /   **  %

## 逻辑运算符

> && || ! 
>
> 短路与: 第一个表达式为true,返回后一个表达式,第一个表示式为false,返回false
>
> 短路或: 第一个表达式为true,返回true,第一个表达式为false,返回后一个表达式

## 关系运算符

> ```
> < > >= <= == != === !==
> ```
>
> + ==只比较值,==比较值得类型

## 赋值运算符

```
= += -= *= /= %=
```

## 二进制运算符

> 异或^  取反~ , ~~可用于取整,二进制运算忽略小数

## 运算符优先级

```
1.()
2.一元运算符 ++ -- !
3.算术运算符 * / % + -
4.关系运算符 >= <= > <
5.相等运算符 == === != !==
6.逻辑运算符 && ||
7.赋值运算符 += -=
8.默认从左到右,除了 ** = ?:
```

# 数据类型转换

### 转化为字符串类型

> 1. 变量.toString()
> 2. String(变量或者数值)
> 3. 通过+,拼接字符串,+一边是字符串就可以实现。
>    + undefined和null不能通过.toString()方法转换

### 转化为数值类型

> 1.Number(数据)  对数据格式要求高,如果数据非法,直接返回NaN。
>
> 2.parseInt(数据) 对数据进行校验,忽略开头0,查到到出现非法数据前。
>
> 3.parseFloat(数据) 遇到多个小数点,只会解析到第二个小数点前,如果是整数就返回整数,其他和parseInt()一样,
>
> 4.+ -
>
> ```
> var num = "22";
> console.log(+ num); //22
> ```

### 转化为布尔类型

> 1. Boolean(数值)
> 2. !!数值
>    + "",0,NaN,false,undefined,null会被转为false,其他都为true。

# 隐式转化



## ++ -- 转换

> 转化为number类型,再进行计算。
>
> ```
> 规范字符串转为数字,不规范字符串和undefined转为NaN,空串和null转化为0,布尔类型true转化为1,false转化为0.
> ```
>
> 

## 逻辑操作符 && || !

> 操作符两边转化为布尔类型,再按操作符规则返回原始数据(不是转化成的布尔数据)。
>
> ```
> null,undefined,"",NaN,0转化为false,其他都为true。
> ```
>
> 

## 关系操作符 >= <= > <

> 操作符号两边都是字符串,按照unicode码按位比较
>
> 其他情况则两边都转为number比较。
>
> + NaN和任何值比较都为false

## 相等操作符 == === 

> 操作符号两边也是转化为数值比较,但是在一些特殊数据比较上有些问题
>
> + tips:
>
>   ```
>   null == undefined //true
>   null === undefined //false
>   null == 0 //false
>   NaN和任何数比较都是false
>   ```
>
>   

## 布尔的隐式转化

> 控制语句中的表达式会被转化为布尔类型
>
> ```
> NaN,0,null,undefined,"",会被转为false,其他为true。
> ```
>
> 

## 数组

> 创建方式
>
> ```
> var arr = new Array(2) 2代表长度
> var arr = new Array(3,6,8) 多个参数代表数组内容
> ```
>
> ```
> var arr = [2, 5]
> ```
>
> 属性: 
>
> ```
> var arr = [2, 5, 6];
> arr.length //3
> arr.length = 4; 空位默认为undefined
> ```
>
> 获取,修改
>
> ```
> var arr = [5, 6, 7];
> arr[1] // 6
> arr[3] = 5
> console.log(arr) //[5,6,7,5]
> ```
>
> 特殊遍历
>
> ```
> for in 和 for of
> for(var index in arr) {
> 	//index代表索引
> }
> for(var item of arr) {
>    //item代表数组值
> }
> 其中forin可能有遍历乱序问题
> ```
>
> 多维数组
>
> ```
> var arr = [[2,4,5],[2,6,7]];
> console.log(arr[1][1]) //6
> ```
>
> 数组类型判断和隐式转换
>
> ``` 
> var arr = [1,2,3]
> typeof arr //object
> Number(arr) //NaN
> Boolean(arr) //true
> String(arr) //"1,2,3"
> [] == [] //false
> arr + "好耶" //1,2,3好耶
> [2] - 1 //1
> [2,] - 1 //1
> [2,1] - 1 //NaN
> !![] // true
> [] + [] // ""
> arr + [] //"1,2,3"
> ```
>
> 
>
> 判断数组方法: Array.isArray(数据) true/false