## 小程序

```
1.需要注册账号 创建项目 进行发布
2.不使用代码编辑器,而是微信开发者工具开发
3.体积小
```

## 结构组成

```
1.app.json 小程序全局配置 有路径,全局配置,当和页面内json文件配置重复时,采用该页面的json配置.
2.project.config.json 项目的配置,appId,项目名称,编译配置等
3.app.wxss 全局样式,每个page都使用
4.sitemap.json 该小程序是否被微信检索 allow | disallow
```

## 新建小程序页面

```
在app.json的pages选项中,添加新页面的路径即可,并且pages数组的第一位作为首页页面
```

## vxss

```
可以使用最新单位rpx
```

## vxml

```
和HTML不同,标签,标签属性不同,具有vue的数据绑定,列表渲染,条件渲染语法等
```

## app.js 和 小程序页面中的js

```
app.js是小程序项目的入口文件,同理,页面中的js也是页面的启动文件.
```

## 环境

```
小程序依赖的环境是手机微信,小程序借助它提供的能力,可以完成很多功能,比如微信扫码,支付,定位等
```

> 小程序的通信: 逻辑层(js)和渲染层(vxss,vxml)和第三方服务器之间的通信,渲染层和逻辑层通过微信客户端通信,逻辑层和第三方服务器通过微信客户端通信.

> 小程序的启动过程: 1)下载小程序数据包 2) 运行app.json配置文件 3)app.js执行,App()创建小程序实例 4) 渲染小程序首页

> 页面渲染过程: 1)运行json配置文件 2)加载vxss,vxml 3)xx.js,创建页面 4)渲染完成

## 常用容器组件

```
1.
view 可以认为是div
scroll-view 可以用于设置滚动条,只需要设置容器固定高宽,在写上scroll-y/scroll-x即可
2.
text 可以认为是span, user-select属性,代表长按进行复制等操作
text-rich nodes="<a href='#'>点击跳转</a>"  可以渲染html内容为实际标签
3.
swiper 轮播图容器
swiper-item 轮播图内容
swiper属性: indicator-dots indicator-color="white" indicator-active-color="pink" circular
autoplay  interval="1500"
4.
button
属性: type='primary' type='warn' | size="mini" | plain 镂空,并有边框
5. image
属性src
属性mode:
aspectFit 等比缩放,当image设置样式中较长一端,能够完整显示图像时停止.
aspectFill 等比缩放,当image设置样式中较短一端,能够完整显示图像时停止.
widthFix 等比缩放,当image设置样式的宽度能够显示完整图像时停止,高度自适应
heightFix 等比缩放,当image设置样式的高度能够显示完整图像时停止,宽度自适应
```

## 小程序API分类

```
1)事件监听API, 以on开头,wx.onWindowResize(function callback)
2)同步API, 以Sync结尾的API,执行结果可以通过函数返回值直接获得.wx.setStorageSync('key','value')
3)异步API ajax,  ex.request()发起网络请求
```

## 数据绑定

```
1.配置
在对应页面的.js中的Page函数中的参数进行配置,key为data,value为一个对象
Page({
data: {
src: "http://xxxxx"
}
})
<image src="{{src}}">
2.使用
可以在{{}}中进行运算,三元
{{type===1?'男':'女'}}
{{number * 10}}
```

## 常用事件

```
1.tap 类似于网页端click
2.input 文本框输入
3.change 状态改变
绑定方式: bind事件名='回调函数名',只能写单纯的函数名,传参通过data-参数='值'的方式传递,在回调函数定义处,通过e.target.dataset取出.
```

+ data-info="{{2}}" 传递数字2  data-info="2" 传递字符2 规则和Vue中一样

> 事件对象的属性

```
target  事件触发的源对象 
currentTarget 绑定了事件的对象
detail input框输入最新值,触发input事件,可以通过e.detail中的value获取最新值
type 事件类型
timeStamp 从页面渲染完成到事件触发的时间间隔
touches 
changedTouches
```

> 回调函数

```
1)书写位置和data属性并列
2)修改data数据通过方法
this.setData({
	key: this.data.key + 其他操作
})
```

## 条件渲染和列表渲染

> 1.条件渲染

```
1. wx:if="{{isShow}}"
2. wx:if="{{type===1}}" wx:elif="{{type===0}}" wx:else
```

> ```
> 一次渲染|不渲染多个组件  用block标签包裹多个组件,block不渲染,类比vue中template
> ```

> hidden 通过样式(display)改变组件显示状态,类比v-show
>
> ```
> <view hidden="{{true}}"></view>
> ```

> 2.列表渲染
>
> ```
> <view wx:for="{{list}}">
> 索引是{{index}} 值是{{item}}
> </view>
> 
> 指定索引变量和索引值变量
> <view wx:for="{{list}}" wx:for-index="idx" wx:for-item="itemName">
> 索引是{{idx}} 值是{{itemName}}
> </view>
> 
> wx:key="index" 不用写{{}}
> ```
>
> 

## wxss

```
1.可以使用rpx单位,原理:设备宽度被默认分割为750rpx,进行自动适配.
2.可以使用@import '相对路径' ,导入wxss样式
```

```
局部样式和全局样式冲突时,看权重.相等时采用局部
```

## 全局配置window

```
1.window包括了navigation, 背景部分
navigation部分:
navigationBarBackgroundColor: hex形式颜色
navigationBarTitleText:
navigationBarTextStyle: white | black
背景部分:
要看到背景部分首先要开启下拉刷新 enablePullDownRefresh: true
然后可以设置背景参数:
backgroundColor hex形式颜色
backgroundTextStyle dark | light

onReachBottomDistance: 数字 代表当下拉框距离顶部多少距离时,加载数据
```

## tabBar

```
在app.json中配置
1)在pages中输入作为tabBar页面的路径
2)和pages参数并列,配置
tarBar: {
	list: [
		{
		pagePath: "页面路径",
		text: "tabbar栏目内容",
		iconPath: "未选择时tab栏图片",
		selectedIconPath: "选中时tab栏图片"
		}
	],
	backgroundColor: "#eee",  //tabBar栏背景色
	borderStyle: "black"  //tabBar栏上边框颜色
	color: "#xxx", // 未选中tab栏文字颜色
	selectedColor: "#xxx" //选中时tab栏文字颜色
}
```

+ 作为tabBar的页面必须在pages数组的前三位,不然无效
+ tabBar最少需要两个页面,最多只能五个页面
+ 渲染顶部tabBar时,不显示图标图片

## 页面配置

```
1) 配置页面窗口表现
配置项和全局配置项中window类似,
在页面.json中出现和app.json中window属性中相同配置,优先使用页面.json中的配置
```

## 小程序中请求数据

> 1.小程序中发送请求的接口域名,必须在后台进行配置,不然无法访问 且 协议需要是https,域名不能是IP和localhost
>
> 开发过程中可以在微信开发者工具中本地设置不限制域名和协议https校验等

```
wx.request({
	url: "xxx",
	method: "GET" || "POST" || xx,
	data: {
		key: value
	},
	success: (res) => {
		res.data //接口返回的数据
	}
})

```

+ 小程序不存在跨域问题,环境是微信客户端,并且发送请求不叫ajax,ajax核心是浏览器中的xhr对象

```
xx.js中:
//页面刚加载时的回调
onLoad (options) {
	//options对象是之前页面跳转过来时携带的参数对象
}
```

## 页面导航

```
1.声明式导航
<navigator url="/pages/xx/xx" open-type='switchTab'></navigator>  //跳转到tabBar页面
<navigator url="/pages/xx/xx" open-type='navigate'></navigator>  //跳转到非tabBar页面 open-type可不写
<navigator open-type="navigateBack" delta="1"></navigator> // delta为1时可不写

带参数时,和url带参一样,xxxxxxx?key=value&key1=value1
<navigator url="/pages/xx/xx?name=jzs&age=22" open-type='switchTab'></navigator>
```

```
2.编程式导航
跳转到tab页面
wx.switchTab({
url: "/pages/xx/xx",
success: () => {
        console.log("jump success");
      },
complete: () => {
        console.log("jump compelete");
      },
fail: () => {
        console.log("jump fail");
      }
})
跳转到非tab页面
wx.navigateTo({
url: "/pages/xx/xx",
})
回退
wx.navigateBack({
delta: 1 //回退一次可不写
})
带参数时,同上,
wx.navigateTo({
url: "/pages/xx/xx?name=jzs&age=22"
})
```

+  switchTab无法携带参数,当需要携带参数到tab页面时可以使用  wx.reLaunch({url: "xx"}) 

## 页面下拉刷新

```
首先需要在xx.json中配置enablePullDownRefresh为true
xx.js中有页面下拉松开的回调函数:
onPullDownRefresh () {
//执行异步后
wx.stopPullDownRefresh()  //取消显示下拉动画
}
```

## 页面上拉刷新

```
页面.json中设置:   onReachBottomDistance: 数字 代表当下拉框距离顶部多少距离时,加载数据
xx.js中有上拉到最底端的回调,
onReachBottom () {

}
用到的API:
wx.showLoading({
      title: '在加载捏',
    })
 wx.hideLoading()
```

## 小程序和页面生命周期和生命周期函数

```
小程序生命周期(应用生命周期)函数:
在app.js中的App函数的配置对象中
onLaunch(options) {
	//当小程序初始化时执行一次,
},
onShow(options) {
	//当小程序启动时执行,或从后台调至前台执行
},
onHide(options) {
	//当小程序隐藏时执行,从前台调至后台
}
```

+ options是当前页的一些信息

```
页面生命周期函数:
在xx.js中的Page函数的配置对象中:
onLoad (options) {
	//监听页面加载,只执行一次
},
onReady() {
	//监听页面初次完成渲染,只执行一次
},
onUnload() {
	//监听页面卸载,只执行一次
},
onShow() {
	//监听页面显示
},
onHide() {
	//监听页面隐藏
}
```

## wxs

```
1.wxs和js是不同语言,只是仿照了很多js的语法
出现原因: wxml中无法使用js中的函数进行数据处理,现在可以使用wxs中暴露的函数对数据进行处理.类比vue中的filters
```

```
2.wxs特点
1)有自己数据类型 2)commonJs规范 3)不支持es6以及以上语法
```

```
3.使用
1)内嵌使用
<view>
  {{t1.toLow(upStr)}}
</view>
<view>
  {{t1.toUp(lowStr)}}
</view>
<wxs module="t1">
  var toLow = function (str) {
    return str.toLowerCase()
  }
  var toUp = function (str) {
    return str.toUpperCase()
  }
  module.exports = {
    toLow: toLow,
    toUp: toUp
  }
</wxs>
2)外部引入
<view>
  {{m2.toUp(lowStr)}}
</view>
<view>
  {{m2.toLow(upStr)}}
</view>
<wxs src="../../utils/test.wxs" module="m2"/>
```

+ wxs环境与js代码隔离,不能使用js中函数,不能调用wxAPI

+ 自定义编译模式,加快不同页面开发效率

## 页面组件

```
1.创建
在项目根目录下,创建components文件夹,再创建项目文件夹,最后输入项目名,自动生成页面文件
2.注册,使用
1)全局使用:
在app.json中配置:
"usingComponents": {
    "test-comp": "/components/test/test"
  },
2)局部使用:
在页面.json中配置:
"usingComponents": {
    "test-comp": "/components/test/test"
  }
  
```

+ 页面和组件的区别: 1)组件的json文件中有"component": true  2)组件的js文件中,初始化函数是Component 3)组件中js文件中的方法,写在methods中,事件方法正常写,自定义方法命名在前面加_

## 组件css样式隔离

```
什么叫样式隔离:
粗糙的说,组件无法使用外部样式,外部无法使用组件内样式.但是它隔离的样式仅仅是通过类选择器选中的样式
```



```
1)在要使用页面的.json文件中配置
"styleIsolation": "shared" || "apply-shared" || isolated
2)在要使用页面的.js文件中配置
Component({
   options: {
     styleIsolation: "shared" || "apply-shared" || isolated
   }
  })
shared:表示组件内和组件外互相共享样式,
apply-shared:表示组件内可以使用组件外样式
```

## 组件内属性

```
1.data
2.methods
3.properties(接收父组件传递的数据)
properties: {
 数据name: {
 type: 数据类型,
 value: 默认值
 },
 数据name: 数据类型
}
组件中properties和data指向一个数据对象,都可以对数据进行读写,只是在用法上进行区分使用,并且properties修改,不会影响父组件数据.
4.数据监听器
observers: {
 "one, two": function (one,two) {
       console.log(one,two,"params");
       this.setData({
         total: one + two
       })
     }
  "obj.name, obj.age": function (name,age) {
       console.log(name,age,"监听到了对象改变");
     }
  "obj.**": function (options) {
  	 //options就是一个新的obj数据对象
     }
}
```

+ 监听对象属性的监听器会被对象该属性值修改和整个对象修改这两种行为触发

```
setData的对象修改用法:
this.setData({
        "rgb.r": this.data.rgb.r + 5 >= 255? 255: this.data.rgb.r + 5
})
```

## 纯数据字段

```
1.不用于渲染的data字段,不用于传递给其他组件,仅在当前组件内部使用,提升页面性能
```

```
2.使用
在页面.js文件的Component函数初始化中进行配置:
options: {
    pureDataPattern: /^_/ (正则匹配成功的data变量名是存数据变量)
 },
 如: data: {
 _test: 99
 }
```

## 组件的生命周期函数和它的页面生命周期函数

```
和data同级:
lifetimes: {
    created() {
      console.log("created 组件实例刚创建好 结构未添加到页面内");
      //不能调用setData
    },
    attached() {
      console.log("attached 组件结构添加到页面内 数据完成初始化 但未渲染");
    },
    ready() {
      console.log("ready 组件完成渲染");
    },
    moved() {
      console.log("moved 组件位置发生改变");
    },
    detached() {\
    //退出一个页面时,会触发页面内每个自定义组件的detached生命周期函数
      console.log("detached 组件被删除");
    },
    error() {
      console.log("error 组件方法抛错执行");
    }
  }
  
  
 pageLifetimes: {
    show () {
      console.log("show");
      this.randomColor()
    },
    hide () {
      console.log("hide");
    },
    resize (resize) {
      console.log("resize");
    }
  }
```

## 插槽

```
1.默认情况下,组件内只允许防止一个插槽
配置多个插槽:
options: {
    multipleSlots: true
}
2.具名插槽
1)组件内:
<slot name="before"></slot>
<slot name="after"></slot>
2)父组件:
<slot-test>
  <view slot="before">
    123
  </view>
  <view slot="after">
    123
  </view>
</slot-test>
```

+ 不能同时使用多个匿名插槽

## 组件通信

```
1.父组件给子组件传递属性(不能传递方法)
2.子组件触发父组件的自定义事件(可以传递任意数据)
1)父组件绑定自定义事件 bind:事件名="本组件内方法"
2)子组件通过this.triggerEvent(事件名,参数)触发事件
3)父组件绑定的方法通过e.detail获取到子组件传递的参数
3.父组件通过this.selectComponent(类名Id选择器)获取到子组件对象,直接访问子组件数据和方法
```

## behaviors

```
类似于vue中的mixins,用于存放组件间共享的数据
behaviors中可以包括属性,方法,data数据,生命周期函数
每个组件可以引用多个behavior,每个behavior也可以引用其他behavior
```

```
1.创建behavior的js文件
behavior.js:
module.exports = Behavior({
  data: {
    name: "jzs",
    age: 22,
    obj: {
      name: "zjc",
      age: 22,
      addr: "jinhua"
    }
  },
  lifetimes: {
    ready() {
      console.log("outer ready");
    },
    created() {
      console.log("outer created");
    }
  },
  methods: {
    getName () {
      console.log("outer");
      return this.data.name
    }
  },
  properties: {
    count: {
      type: Number,
      value: 99
    }
  }
})
2.在组件内引入并使用
const behavior = require("../../behavior/behavior")
Component({
  behaviors: [behavior],
  xxxxx })
```

![](D:\gitLocal\8. 小程序\behavior.png)

## 属性重名情况

```
1.data重名,如果是对象类型则进行合并,普通值采用组件内的值
2.方法重名,采用组件内
3.properties重名,采用组件内
3.生命周期重名,优先执行behavior中,再执行组件内
```

## 小程序的UI组件库  vantweapp

```
1.在项目中安装vantweapp
先初始化环境 npm init -y
安装vantweapp npm i @vant/weapp@1.3.3 -S --production
2.然后通过 工具>构建npm 生成miniprogram_npm代码库
3.删除app.json中stlye:v2,防止最新样式和组件样式冲突
```

```
2.使用组件
可以全局引入或者局部引入
"usingComponents": {
  "van-button": "@vant/weapp/button/index"
}
```

```
3.定制全局主体,对组件样式进行修改
app.wxss下:
page {
	--button-primary-color: cyan;
  --button-primary-background-color: pink;
  --button-primary-border-color: grey;
}
page是小程序页面顶级标签
样式变量查文档表可得
```

+ 样式变量具有作用域,不在该作用域下的元素使用该样式无效.

## API promise化

```
1.下载包
npm i --save miniprogram-api-promise@1.0.4
2.在app.js中引入函数执行
import {promisifyAll} from "miniprogram-api-promise"
const wxp = wx.p = {}
promisifyAll(wx,wxp) //将wx上的方法promise化后合并在wxp上
```

## 全局数据共享

```
小程序中可以使用mobx

1.加载包
npm i --save mobx-miniprogram mobx-miniprogram-bindings
npm i --save mobx-miniprogram@4.13.2 mobx-miniprogram-bindings@1.2.1
```

+ 下载新包后先把原miniprogram文件夹删除,再重新构建.

```
2.创建store仓库对象

在根目录创建store文件夹,store.js

import {observable, action} from "mobx-miniprogram"
export const store = observable({
	name: "jzs",
	age: 22,
	count1: 0,
	count2: 0,
	get info () {
	return this.name + this.age //计算属性
	},
	updateOne: action(function (p) {
		//方法1
	}),
	updateTwo: action(function (p) {
		//方法2
	})
})

3.在页面中使用store中数据和方法
页面.js中:
import {createStoreBindings} from "mobx-miniprogram-bindings"
import {store} from "../../store/store"
onLoad (options) {
	this.storeBindsObj = createStoreBindings(this,{
	store,
	fields: ["name","age","addr","info","count1","count2"],
	actions: ["updateOne","updateTwo"]
	})
}
onUnload() {
	this.storeBindsObj.destroyStoreBindings()
}

4.在组件中使用store中数据和方法
import [storeBindingsBehavior] from "mobx-miniprogram-bindings"
import {store} from "../../store/store"
Component({
behaviors: [storeBindingsBehavior],
storeBindings: {
store,
fields: {
// count1: "count1",
count1: () => store.count1,
// count2: "count2"
count2: (store) => store.count2
},
actions: {
updateOne: "updateOne",
updateTwo: "updateTwo"
}
}
})
```

## 分包

```
在app.json中进行配置:

subPackages: [
	{
      "root": "packageOne", //分包根目录
      "name": "p1", //分包别名
      "pages": [
        "pages/index/index", //分包中页面1
        "pages/user/user" //分包中页面2
      ]
    },
    {
      "root": "packageTwo",
      "name": "p2",
      "pages": [
        "pages/addr/addr"
      ],
      "independent": true
    }
]
```

+ 打包原则,subPackages外的资源都被打包到主包中, tabBar页面必须在主包中, 主包页面放在根目录的pages中.

+ 引用原则: 主包不能用分包资源,分包之间不能使用资源,子包可以使用主包资源.

## 独立分包

```
独立分包:可以独立启动的分包,不用依赖于主包启动而启动.
在分包配置中加上:
"independent": true
```

+ 独立分包不能引用主包资源

## 分包预加载

```
1.在进入某个页面后,预先加载可能要使用的分包
app.json中配置:
preloadRule: {
	"pages/home/home": {
		network: "wifi" || "all",
		packages: ["分包root或者分包别名name","xx"]
	}
}
```

+ 一个包中所有页面的预加载分包大小总和不能超过2M

## 自定义tabBar

```
官网: 指南 > 自定义组件 >基础能力
看文档:https://developers.weixin.qq.com/miniprogram/dev/framework/ability/custom-tabbar.html
```

+ 自定义tabBar组件中修改vantweapp中组件,需要在json中设置styleIsolation: "shared"